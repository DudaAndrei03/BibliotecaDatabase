-- Generated by Oracle SQL Developer Data Modeler 24.3.0.240.1210
--   at:        2025-01-01 14:23:43 EET
--   site:      Oracle Database 11g
--   type:      Oracle Database 11g



-- predefined type, no DDL - MDSYS.SDO_GEOMETRY

-- predefined type, no DDL - XMLTYPE

CREATE TABLE abonament (
    tip_abonament VARCHAR2(10 CHAR) NOT NULL,
    pret          NUMBER(3) NOT NULL
)
LOGGING;

ALTER TABLE abonament
    ADD
        CHECK ( tip_abonament IN ( 'Bronze', 'Gold', 'Platinum', 'Silver' ) );

COMMENT ON COLUMN abonament.tip_abonament IS
    'Valorile care pot fi date sunt : 
Bronze/Silver/Gold/Platinum
in functie de tipul de abonament ales';

CREATE UNIQUE INDEX abonament_tip_abonament_idx ON
    abonament (
        tip_abonament
    ASC );

ALTER TABLE abonament ADD CONSTRAINT abonament_pk PRIMARY KEY ( tip_abonament );

CREATE TABLE carti (
    id_carte     NUMBER(4) NOT NULL,
    titlu        VARCHAR2(30 CHAR) NOT NULL,
    autor        VARCHAR2(25 CHAR) NOT NULL,
    an_publicare VARCHAR2(4 CHAR) NOT NULL,
    exemplare    NUMBER(3) NOT NULL
)
LOGGING;

CREATE UNIQUE INDEX carti_id_carte_idx ON
    carti (
        id_carte
    ASC );

ALTER TABLE carti ADD CONSTRAINT carti_pk PRIMARY KEY ( id_carte );

ALTER TABLE carti
    ADD CONSTRAINT carti_un UNIQUE ( titlu,
                                     autor,
                                     an_publicare );

CREATE TABLE imprumuturi (
    id_imprumut       NUMBER(4) NOT NULL,
    data_imprumutului DATE NOT NULL,
    data_returnarii   DATE NOT NULL,
    statut            NUMBER(1),
    id_utilizator     NUMBER(4) NOT NULL,
    id_carte          NUMBER(4) NOT NULL
)
LOGGING;

ALTER TABLE imprumuturi
    ADD CONSTRAINT imprumuturi_statut_ck CHECK ( statut IN ( 0, 1 ) );

CREATE UNIQUE INDEX imprumuturi__idx ON
    imprumuturi (
        id_imprumut
    ASC,
        id_utilizator
    ASC,
        id_carte
    ASC )
        LOGGING;

ALTER TABLE imprumuturi ADD CONSTRAINT imprumuturi_pk PRIMARY KEY ( id_imprumut );

ALTER TABLE imprumuturi
    ADD CONSTRAINT imprumuturi__un UNIQUE ( id_carte,
                                            data_imprumutului,
                                            id_utilizator );

CREATE TABLE review (
    id_review     NUMBER(4) NOT NULL,
    opinie        VARCHAR2(100 CHAR) NOT NULL,
    nota          NUMBER(4, 2) NOT NULL,
    id_carte      NUMBER(4) NOT NULL,
    id_utilizator NUMBER(4) NOT NULL
)
LOGGING;

ALTER TABLE review
    ADD CONSTRAINT intervalnota_ck CHECK ( nota BETWEEN 1 AND 10 );

CREATE UNIQUE INDEX review_id_review_idx ON
    review (
        id_review
    ASC );

ALTER TABLE review ADD CONSTRAINT review_pk PRIMARY KEY ( id_review );

ALTER TABLE review
    ADD CONSTRAINT review__un UNIQUE ( id_carte,
                                       id_utilizator,
                                       opinie );

CREATE TABLE sanctiuni (
    id_sanctiune           NUMBER(4) NOT NULL,
    motiv                  VARCHAR2(100),
    durata_sanctiune       NUMBER(4) NOT NULL,
    data_inceput_sanctiune DATE NOT NULL,
    id_utilizator          NUMBER(4) NOT NULL
)
LOGGING;

CREATE INDEX sanctiuni__idx ON
    sanctiuni (
        id_sanctiune
    ASC,
        id_utilizator
    ASC )
        LOGGING;

ALTER TABLE sanctiuni ADD CONSTRAINT sanctiuni_pk PRIMARY KEY ( id_sanctiune );

CREATE TABLE utilizatori (
    id_utilizator   NUMBER(4) NOT NULL,
    nume            VARCHAR2(20 CHAR) NOT NULL,
    prenume         VARCHAR2(20 CHAR) NOT NULL,
    email           VARCHAR2(50 CHAR),
    parola          VARCHAR2(20 CHAR) NOT NULL,
    data_inscrierii VARCHAR2(10 CHAR) NOT NULL,
    tip_abonament   VARCHAR2(10 CHAR) NOT NULL
)
LOGGING;

ALTER TABLE utilizatori
    ADD CONSTRAINT utilizatori_email_clk CHECK ( REGEXP_LIKE ( email,
                                                               '[a-z0-9._%-]+@[a-z0-9._%-]+\.[a-z]{2,4}' ) );

ALTER TABLE utilizatori
    ADD CONSTRAINT utilizatori_parola_ck CHECK ( REGEXP_LIKE ( parola,
                                                               '^.{5,}$' ) );

ALTER TABLE utilizatori ADD constraint utilizatori_data_inscrierii.ck CHECK ( REGEXP_LIKE ( data_inscrierii,
                                                                                            '^(0?[1-9]|[12][0-9]|3[01])\.(0?[1-9]|1[0-2])\.(19|20)[0-9]{2}$'
                                                                                            ) );

COMMENT ON COLUMN utilizatori.data_inscrierii IS
    'Datele valide vor fi de forma: xx.xx.xxxx';

CREATE UNIQUE INDEX utilizatori_id_utilizator_idx ON
    utilizatori (
        id_utilizator
    ASC );

ALTER TABLE utilizatori ADD CONSTRAINT utilizatori_pk PRIMARY KEY ( id_utilizator );

ALTER TABLE utilizatori ADD CONSTRAINT cont_un UNIQUE ( id_utilizator,
                                                        parola );

ALTER TABLE utilizatori ADD CONSTRAINT utilizatori_email_un UNIQUE ( email );

ALTER TABLE review
    ADD CONSTRAINT carti_review_fk
        FOREIGN KEY ( id_carte )
            REFERENCES carti ( id_carte )
            NOT DEFERRABLE;

ALTER TABLE imprumuturi
    ADD CONSTRAINT imprumuturi_carti_fk
        FOREIGN KEY ( id_carte )
            REFERENCES carti ( id_carte )
            NOT DEFERRABLE;

ALTER TABLE imprumuturi
    ADD CONSTRAINT imprumuturi_utilizatori_fk
        FOREIGN KEY ( id_utilizator )
            REFERENCES utilizatori ( id_utilizator )
            NOT DEFERRABLE;

ALTER TABLE sanctiuni
    ADD CONSTRAINT sanctiuni_utilizatori_fk
        FOREIGN KEY ( id_utilizator )
            REFERENCES utilizatori ( id_utilizator )
            NOT DEFERRABLE;

ALTER TABLE utilizatori
    ADD CONSTRAINT utilizatori_abonament_fk
        FOREIGN KEY ( tip_abonament )
            REFERENCES abonament ( tip_abonament )
            NOT DEFERRABLE;

ALTER TABLE review
    ADD CONSTRAINT utilizatori_review_fk
        FOREIGN KEY ( id_utilizator )
            REFERENCES utilizatori ( id_utilizator )
            NOT DEFERRABLE;

CREATE OR REPLACE TRIGGER TRG_EXEMPLARE_OK 
    BEFORE INSERT OR UPDATE ON Imprumuturi 
    FOR EACH ROW 
DECLARE
    v_exemplare NUMBER;  -- Variabilă pentru a stoca numărul de exemplare
BEGIN
    -- Obține numărul de exemplare din tabela carti pentru cartea împrumutată
    SELECT exemplare
    INTO v_exemplare
    FROM carti
    WHERE id_carte = :NEW.id_carte;

    -- Verifică dacă sunt exemplare disponibile
    IF v_exemplare > 0 THEN
        -- Actualizează tabela carti, scăzând un exemplar
        UPDATE carti
        SET exemplare = exemplare - 1
        WHERE id_carte = :NEW.id_carte;
    ELSE
        -- Dacă nu sunt exemplare disponibile, aruncă o eroare
        RAISE_APPLICATION_ERROR(-20001, 'Nu mai sunt exemplare disponibile pentru această carte.');
    END IF;
END; 
/

CREATE OR REPLACE TRIGGER Trg_Imprumuturi_Data_Imprumutului 
    BEFORE INSERT OR UPDATE ON Imprumuturi 
    FOR EACH ROW 
BEGIN
	IF( :new.Data_Imprumutului > SYSDATE ) 
	THEN
		RAISE_APPLICATION_ERROR( -20001,
			'Data invalida: ' || TO_CHAR ( :new.Data_Imprumutului, 'DD.MM.YYYY HH24:MI:SS' ) || 'trebuie sa fie mai mica decat data curenta.' );
	END IF;
END; 
/

CREATE OR REPLACE TRIGGER Trg_Imprumuturi_Data_Ordine 
    BEFORE INSERT OR UPDATE ON Imprumuturi 
    FOR EACH ROW 
BEGIN
    -- Verifică dacă data de început este mai mare decât data de terminare
    IF ( :NEW.Data_Imprumutului >= :NEW.Data_Returnarii) THEN
        RAISE_APPLICATION_ERROR(-20004,
            'Data de incepere nu poate fi mai mare sau egala cu data de terminare: ' ||
            TO_CHAR(:NEW.Data_Imprumutului, 'DD.MM.YYYY') || ' trebuie sa fie mai mica decat ' ||
            TO_CHAR(:NEW.Data_Returnarii, 'DD.MM.YYYY'));
    END IF;
END; 
/

CREATE OR REPLACE TRIGGER Trg_Imprumuturi_Data_Returnarii 
    BEFORE INSERT OR UPDATE ON Imprumuturi 
    FOR EACH ROW 
/*BEGIN
	IF( :new.Data_Returnarii > TRUNC(SYSDATE) ) --Data Curenta nu poate sa fie cu o zi in trecut!
	THEN
		RAISE_APPLICATION_ERROR( -20001,
			'Data invalida: ' || TO_CHAR ( :new.Data_Returnarii, 'DD.MM.YYYY HH24:MI:SS' ) || 'trebuie sa fie mai mica decat data curenta.' );
	END IF;
END;*/ ;
/

CREATE OR REPLACE TRIGGER Trg_Sanctiuni_Data_Inceput_Sanctiune 
    BEFORE INSERT OR UPDATE ON Sanctiuni 
    FOR EACH ROW 
BEGIN
	IF( :new.Data_Inceput_Sanctiune > SYSDATE ) 
	THEN
		RAISE_APPLICATION_ERROR( -20001,
			'Data invalida: ' || TO_CHAR ( :new.Data_Inceput_Sanctiune, 'DD.MM.YYYY HH24:MI:SS' ) || 'trebuie sa fie mai mica decat data curenta.' );
	END IF;
END; 
/

CREATE OR REPLACE TRIGGER Trg_Utilizatori_Data 
    BEFORE INSERT OR UPDATE ON Utilizatori 
    FOR EACH ROW 
BEGIN
	IF( :new.Data_Inscrierii > SYSDATE ) --Data Curenta nu poate sa fie in viitor
	THEN
		RAISE_APPLICATION_ERROR( -20001,
			'Data invalida: ' || TO_CHAR ( :new.ID_Utilizator, 'DD.MM.YYYY HH24:MI:SS' ) || 'trebuie sa fie mai mica decat data curenta.' );
	END IF;
END; 
/

CREATE SEQUENCE carti_id_carte_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER carti_id_carte_trg BEFORE
    INSERT ON carti
    FOR EACH ROW
    WHEN ( new.id_carte IS NULL )
BEGIN
    :new.id_carte := carti_id_carte_seq.nextval;
END;
/

CREATE SEQUENCE imprumuturi_id_imprumut_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER imprumuturi_id_imprumut_trg BEFORE
    INSERT ON imprumuturi
    FOR EACH ROW
    WHEN ( new.id_imprumut IS NULL )
BEGIN
    :new.id_imprumut := imprumuturi_id_imprumut_seq.nextval;
END;
/

CREATE SEQUENCE review_id_review_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER review_id_review_trg BEFORE
    INSERT ON review
    FOR EACH ROW
    WHEN ( new.id_review IS NULL )
BEGIN
    :new.id_review := review_id_review_seq.nextval;
END;
/

CREATE SEQUENCE sanctiuni_id_sanctiune_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER sanctiuni_id_sanctiune_trg BEFORE
    INSERT ON sanctiuni
    FOR EACH ROW
    WHEN ( new.id_sanctiune IS NULL )
BEGIN
    :new.id_sanctiune := sanctiuni_id_sanctiune_seq.nextval;
END;
/

CREATE SEQUENCE utilizatori_id_utilizator_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER utilizatori_id_utilizator_trg BEFORE
    INSERT ON utilizatori
    FOR EACH ROW
    WHEN ( new.id_utilizator IS NULL )
BEGIN
    :new.id_utilizator := utilizatori_id_utilizator_seq.nextval;
END;
/



-- Oracle SQL Developer Data Modeler Summary Report: 
-- 
-- CREATE TABLE                             6
-- CREATE INDEX                             6
-- ALTER TABLE                             23
-- CREATE VIEW                              0
-- ALTER VIEW                               0
-- CREATE PACKAGE                           0
-- CREATE PACKAGE BODY                      0
-- CREATE PROCEDURE                         0
-- CREATE FUNCTION                          0
-- CREATE TRIGGER                          11
-- ALTER TRIGGER                            0
-- CREATE COLLECTION TYPE                   0
-- CREATE STRUCTURED TYPE                   0
-- CREATE STRUCTURED TYPE BODY              0
-- CREATE CLUSTER                           0
-- CREATE CONTEXT                           0
-- CREATE DATABASE                          0
-- CREATE DIMENSION                         0
-- CREATE DIRECTORY                         0
-- CREATE DISK GROUP                        0
-- CREATE ROLE                              0
-- CREATE ROLLBACK SEGMENT                  0
-- CREATE SEQUENCE                          5
-- CREATE MATERIALIZED VIEW                 0
-- CREATE MATERIALIZED VIEW LOG             0
-- CREATE SYNONYM                           0
-- CREATE TABLESPACE                        0
-- CREATE USER                              0
-- 
-- DROP TABLESPACE                          0
-- DROP DATABASE                            0
-- 
-- REDACTION POLICY                         0
-- 
-- ORDS DROP SCHEMA                         0
-- ORDS ENABLE SCHEMA                       0
-- ORDS ENABLE OBJECT                       0
-- 
-- ERRORS                                   0
-- WARNINGS                                 0
